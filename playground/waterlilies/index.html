<!DOCTYPE html>
<html>
<head>
    <title>Mossy Pond with Lilies</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
        }
        #instructions {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            pointer-events: none;
        }
        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
        button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
            font-family: Arial, sans-serif;
        }
        button.active {
            background: #2E7D32;
        }
        button:hover {
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="rockBtn">Place Rocks</button>
        <button id="lilyBtn">Place Lilies</button>
        <button id="resetBtn">Reset</button>
    </div>
    <div id="instructions">
        Click/tap to add objects<br>
        Tilt device or move mouse to create waves
    </div>
    <script>
        let cols;
        let rows;
        let current;
        let previous;
        let             dampening = 0.992;
        let rocks = [];
        let lilies = [];
        let tiltAngle = { x: 0, y: 0 };
        let placeMode = 'rock'; // 'rock' or 'lily'

        class WaterLily {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.targetX = x;
                this.targetY = y;
                this.size = random(60, 100);
                this.rotation = random(TWO_PI);
                this.vx = 0;
                this.vy = 0;
                // Add hasFlower property that stays constant
                this.hasFlower = random() < 0.5;
            }

            update(rippleForce) {
                // Very gentle ripple force scaling
                let amplifiedForceX = rippleForce.x * 0.1;
                let amplifiedForceY = rippleForce.y * 0.1;
                
                // Move lily pad based on water ripples with minimal sensitivity
                this.vx = lerp(this.vx, amplifiedForceX, 0.05);
                this.vy = lerp(this.vy, amplifiedForceY, 0.05);
                
                // Very strong damping for minimal movement
                this.vx *= 0.92;
                this.vy *= 0.92;
                
                this.x += this.vx;
                this.y += this.vy;
                
                // Minimal rotation
                this.rotation += (this.vx + this.vy) * 0.01;
                
                // Quick return to original position
                this.x = lerp(this.x, this.targetX, 0.04);
                this.y = lerp(this.y, this.targetY, 0.04);
                
                // Keep within bounds
                this.x = constrain(this.x, 0, width);
                this.y = constrain(this.y, 0, height);
                
                this.x += this.vx;
                this.y += this.vy;
                
                // More pronounced rotation based on ripple movement
                this.rotation += (this.vx + this.vy) * 0.05;
                
                // Slower return to original position for more drifting
                this.x = lerp(this.x, this.targetX, 0.002);
                this.y = lerp(this.y, this.targetY, 0.002);
                
                // Keep within bounds
                this.x = constrain(this.x, 0, width);
                this.y = constrain(this.y, 0, height);
            }

            draw() {
                push();
                translate(this.x, this.y);
                rotate(this.rotation);
                
                // Draw lily pad with pixelated retro style
                noStroke();
                
                // Main pad shape - simplified and chunky
                // Base shadow
                fill(34, 80, 34, 200);
                rect(-this.size/2 + 4, -this.size*0.4 + 4, this.size/4, this.size*0.4, 2);
                rect(-this.size/4, -this.size*0.4 + 4, this.size/2, this.size*0.4, 2);
                
                // Main green blocks
                fill(67, 124, 23, 230);
                rect(-this.size/2, -this.size*0.4, this.size/4, this.size*0.4, 2);
                rect(-this.size/4, -this.size*0.4, this.size/2, this.size*0.4, 2);
                
                // Highlight blocks
                fill(162, 201, 39, 180);
                rect(-this.size/2 + 2, -this.size*0.4 + 2, this.size/8, this.size*0.2, 1);
                
                // Draw retro-style flower with chunky pixels
                if (this.hasFlower) {
                    // Flower base - larger pixels
                    fill(219, 112, 147, 200);
                    rect(-12, -12, 8, 8);
                    rect(4, -12, 8, 8);
                    rect(-12, 4, 8, 8);
                    rect(4, 4, 8, 8);
                    
                    // Brighter center
                    fill(255, 182, 193, 230);
                    rect(-6, -6, 12, 12);
                    
                    // Yellow center pixel
                    fill(255, 223, 51, 250);
                    rect(-4, -4, 8, 8);
                }
                
                pop();
            }
        }

        function setup() {
            createCanvas(windowWidth, windowHeight);
            pixelDensity(1);
            // Reduce resolution - each cell represents 4x4 pixels
            cols = Math.floor(width/4);
            rows = Math.floor(height/4);
            
            // Create 2D arrays
            current = new Array(cols).fill(0).map(() => new Array(rows).fill(0));
            previous = new Array(cols).fill(0).map(() => new Array(rows).fill(0));
            
            // Setup UI controls
            document.getElementById('rockBtn').onclick = () => {
                placeMode = 'rock';
                document.getElementById('rockBtn').classList.add('active');
                document.getElementById('lilyBtn').classList.remove('active');
            };
            document.getElementById('lilyBtn').onclick = () => {
                placeMode = 'lily';
                document.getElementById('lilyBtn').classList.add('active');
                document.getElementById('rockBtn').classList.remove('active');
            };
            document.getElementById('resetBtn').onclick = () => {
                rocks = [];
                lilies = [];
                current = new Array(cols).fill(0).map(() => new Array(rows).fill(0));
                previous = new Array(cols).fill(0).map(() => new Array(rows).fill(0));
            };
            
            // Set initial button state
            document.getElementById('rockBtn').classList.add('active');
            
            // Setup device motion
            if (typeof DeviceMotionEvent !== 'undefined' && 
                typeof DeviceMotionEvent.requestPermission === 'function') {
                DeviceMotionEvent.requestPermission()
                    .then(response => {
                        if (response == 'granted') {
                            window.addEventListener('devicemotion', handleMotion);
                        }
                    })
                    .catch(console.error);
            } else {
                window.addEventListener('devicemotion', handleMotion);
            }
        }

        function handleMotion(event) {
            tiltAngle.x = event.accelerationIncludingGravity.x * 2;
            tiltAngle.y = event.accelerationIncludingGravity.y * 2;
        }

        function mouseMoved() {
            if (mouseX > 0 && mouseX < width && mouseY > 0 && mouseY < height) {
                let gridX = Math.floor(mouseX/4);
                let gridY = Math.floor(mouseY/4);
                if (gridX > 0 && gridX < cols && gridY > 0 && gridY < rows) {
                    previous[gridX][gridY] = 500;
                }
            }
            return false;
        }

        function touchMoved(event) {
            if (touches.length > 0) {
                let touch = touches[0];
                let gridX = Math.floor(touch.x/4);
                let gridY = Math.floor(touch.y/4);
                if (gridX > 0 && gridX < cols && gridY > 0 && gridY < rows) {
                    previous[gridX][gridY] = 500;
                }
            }
            return false;
        }

        function mousePressed() {
            if (mouseX < 0 || mouseX > width || mouseY < 0 || mouseY > height) return false;
            
            if (placeMode === 'rock') {
                rocks.push({ x: mouseX, y: mouseY, size: random(40, 80) });
            } else if (placeMode === 'lily') {
                lilies.push(new WaterLily(mouseX, mouseY));
            }
            return false;
        }

        function draw() {
            background(0);
            loadPixels();
            
            // Apply tilt effect
            let tiltForceX = map(tiltAngle.x, -10, 10, -2, 2);
            let tiltForceY = map(tiltAngle.y, -10, 10, -2, 2);
            
            // Calculate water ripples with rock collision
            for (let i = 1; i < cols - 1; i++) {
                for (let j = 1; j < rows - 1; j++) {
                    // Check if current point is inside any rock
                    let isRock = rocks.some(rock => {
                        let dx = i*4 - rock.x;
                        let dy = j*4 - rock.y;
                        return dx * dx + dy * dy < rock.size * rock.size / 4;
                    });
                    
                    if (!isRock) {
                        current[i][j] = (
                            previous[i-1][j] + 
                            previous[i+1][j] + 
                            previous[i][j-1] + 
                            previous[i][j+1]
                        ) / 2 - current[i][j];
                        current[i][j] = current[i][j] * dampening;
                        current[i][j] += tiltForceX + tiltForceY;
                    } else {
                        current[i][j] = -previous[i][j];
                    }
                    
                    // Scale back up to screen coordinates
                    let rippleIntensity = current[i][j];
                    let baseR = 70 + rippleIntensity;
                    let baseG = 100 + rippleIntensity;
                    let baseB = 170 + rippleIntensity;
                    
                    // Add subtle purple variations using simplified noise
                    let noiseVal = noise(i * 0.1, j * 0.1, frameCount * 0.01);
                    if (noiseVal > 0.5) {
                        baseR += 20;
                        baseB += 10;
                    }
                    
                    // Fill 4x4 pixel block
                    for (let x = 0; x < 4; x++) {
                        for (let y = 0; y < 4; y++) {
                            let index = ((i * 4 + x) + (j * 4 + y) * width) * 4;
                            if (index < pixels.length - 4) {
                                if (isRock) {
                                    pixels[index + 0] = 150;
                                    pixels[index + 1] = 150;
                                    pixels[index + 2] = 150;
                                } else {
                                    pixels[index + 0] = baseR;
                                    pixels[index + 1] = baseG;
                                    pixels[index + 2] = baseB;
                                }
                                pixels[index + 3] = 255;
                            }
                        }
                    }
                }
            }
            
            updatePixels();
            
            // Update and draw lilies
            for (let lily of lilies) {
                // Convert lily position to grid coordinates
                let gridX = Math.floor(lily.x / 4);
                let gridY = Math.floor(lily.y / 4);
                
                // Ensure we're within grid bounds
                if (gridX > 0 && gridX < cols-1 && gridY > 0 && gridY < rows-1) {
                    // Calculate ripple forces from surrounding cells
                // Calculate ripple forces from surrounding cells
                    let rippleForce = {
                        x: (current[gridX+1][gridY] - current[gridX-1][gridY]) * 0.15,
                        y: (current[gridX][gridY+1] - current[gridX][gridY-1]) * 0.15
                    };
                    lily.update(rippleForce);
                }
                lily.draw();
            }
            
            // Swap buffers
            let temp = previous;
            previous = current;
            current = temp;
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            cols = width;
            rows = height;
            current = new Array(cols).fill(0).map(() => new Array(rows).fill(0));
            previous = new Array(cols).fill(0).map(() => new Array(rows).fill(0));
        }
    </script>
</body>
</html>